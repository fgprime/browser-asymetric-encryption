import Head from "next/head";
import styles from "../styles/Home.module.css";
import { useEffect, useState } from "react";

const MESSAGE =
  "Lorem ipsum dolor sit amet, qui minim labore adipisicing minim sint cillum sint consectetur cupidatat.";

export default function Home() {
  const [message, setMessage] = useState(MESSAGE);
  const [ciphertext, setCiphertext] = useState(null);
  const [encryption, setEncryption] = useState(false);
  const [cryptoKey, setCryptoKey] = useState(null);


  useEffect(() => {
    const creatCryptoKey = async () => {
      const publicKeyPem = await loadPublicKey();
      const result = await createCryptoKeyFromPublicKey(publicKeyPem);
      setCryptoKey(result);
    }
    creatCryptoKey();
  }, []);

  const loadPublicKey = async () => {
    const response = await fetch("publickey");
    try {
      if (!response.ok) {
        throw new Error("Network response failed");
      }
      return response.text();
    } catch (error) {
      console.error(error);
    }

  };

  const createCryptoKeyFromPublicKey = (publicKeyPem) => {
    return crypto.subtle.importKey(
      "spki",
      pemToBinary(publicKeyPem),
      {
        name: "RSA-OAEP",
        hash: "SHA-256",
      },
      true,
      ["encrypt"]
    );
  };

  const encryptMessage = async (message, key) => {
    const encoder = new TextEncoder();
    const encoded = encoder.encode(message);

    const cipherArray = await window.crypto.subtle.encrypt(
      { name: "RSA-OAEP" },
      key,
      encoded
    );
    setCiphertext(cipherArray);

    return Uint8Array.from(cipherArray.toString(), (c) => c.charCodeAt(0)).join('')

  };

  const decryptMessage = async (key) => {
    const originalText = await window.crypto.subtle.decrypt(
      {
        name: "RSA-OAEP",
      },
      key,
      ciphertext
    );

    const decoder = new TextDecoder();
    return decoder.decode(originalText);
  };

  const encrypt = async () => {
    const cipher = await encryptMessage(message, cryptoKey);
    setEncryption(true);
    setMessage(cipher);
  };

  const decrypt = async () => {
    try {
      const key = await privateKey();
      const message = await decryptMessage(key);
      setEncryption(false);
      setMessage(message);
    } catch (error) {
      console.error(error)
    }
  };

  const pemToBinary = (pem) => {
    const lines = pem.split("\n");
  
    const start = lines.findIndex((element) => {
      return element.includes("BEGIN") && element.includes("KEY");
    });

    const end = lines.findIndex((element) => {
      return element.includes("END") && element.includes("KEY");
    });

    if (end === -1 || start === -1) throw new Error("Invalid PEM file");

    const encoded = lines
      .filter((_, index) => index > start && index < end)
      .join("").replace(/\s/g, "");

    return Uint8Array.from(window.atob(encoded), (c) => c.charCodeAt(0));
  };

  // Remove from production code
  const privateKey = () => {
    return crypto.subtle.importKey(
      "pkcs8",
      pemToBinary(process.env.privateKey),
      {
        name: "RSA-OAEP",
        hash: "SHA-256",
      },
      false,
      ["decrypt"]
    );
  };

  return (
    <div className={styles.container}>
      <Head>
        <title>Encryption example</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <h1>En/Decryption example</h1>
        <p><input type="text" value={message} readOnly={encryption} onChange={(e) => setMessage(e.target.value)} /></p>
        {encryption ? <button onClick={() => decrypt()}>Decrypt </button> : <button onClick={() => encrypt()}>Encrypt</button>}
      </main>
    </div>
  );
}